<!DOCTYPE html>
<html>
  <head>
    <title>Dublin Bikes App</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>
    <link rel="stylesheet" href={{ url_for('static', filename='style.css') }}>
    <script>
      // by default the selected view on page load is "Available Bikes"
      let viewAvailableBikes = true;
      let map;
      let infowindow;
      let markersArray = [];
      let chart;
      let overlay;

      function selectAvailableBikesView() {
        // if the view is already selected don't do anything
        if (viewAvailableBikes) {
          return;
        }
        viewAvailableBikes = true;
        changeViewTitle();
        updateMarkers();
      };

      function selectFreeSpacesView() {
        if (!viewAvailableBikes){
          return;
        }
        viewAvailableBikes = false;
        changeViewTitle();
        updateMarkers();
      };

      function initMap() {
        changeViewTitle();
        map = new google.maps.Map(document.getElementById("map"), {
          center: { lat: 53.3498, lng: -6.2603 },
          zoom: 14,
        });

        updateMarkers();
      }

      function updateMarkers() {
        const bounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(53.342271085874636, -6.2620039424284215),
          new google.maps.LatLng(53.349777640548794, -6.252099752008924)
        );

        /**
         * The custom LoadingOverlay object contains the loading gif,
         * the bounds of the image, and a reference to the map.
         * Must be defined inside the updateMarkers function because it requires a
         * reference to google maps API
         */
         class LoadingOverlay extends google.maps.OverlayView {
            constructor(bounds, image) {
                super();
                this.bounds = bounds;
                this.image = loadingGif;
            }
            /**
             * onAdd is called when the map's panes are ready and the overlay has been
             * added to the map.
             */
            onAdd() {
                this.div = document.createElement("div");
                this.div.style.borderStyle = "none";
                this.div.style.borderWidth = "0px";
                this.div.style.position = "absolute";
                // Create the img element and attach it to the div.
                const img = document.createElement("img");
                img.src = this.image;
                img.style.width = "50%";
                img.style.height = "50%";
                img.style.position = "absolute";
                this.div.appendChild(img);
                // Add the element to the "overlayLayer" pane.
                const panes = this.getPanes();
                panes.overlayLayer.appendChild(this.div);
            }
            draw() {
                // We use the south-west and north-east
                // coordinates of the overlay to peg it to the correct position and size.
                // To do this, we need to retrieve the projection from the overlay.
                const overlayProjection = this.getProjection();
                // Retrieve the south-west and north-east coordinates of this overlay
                // in LatLngs and convert them to pixel coordinates.
                // We'll use these coordinates to resize the div.
                const sw = overlayProjection.fromLatLngToDivPixel(
                    this.bounds.getSouthWest()
                );
                const ne = overlayProjection.fromLatLngToDivPixel(
                    this.bounds.getNorthEast()
                );

                // Resize the image's div to fit the indicated dimensions.
                if (this.div) {
                    this.div.style.left = sw.x + "px";
                    this.div.style.top = ne.y + "px";
                    this.div.style.width = ne.x - sw.x + "px";
                    this.div.style.height = sw.y - ne.y + "px";
                }
            }
            /**
             *  Set the visibility to 'hidden' or 'visible'.
             */
            hide() {
                if (this.div) {
                    this.div.style.visibility = "hidden";
                }
            }
        }

        // Setup loading symbol
        let loadingGif = "/static/ajax-loader.gif";
        overlay = new LoadingOverlay(bounds, loadingGif);
        overlay.setMap(map);

        // We have one infowindow that is shared between all stations so that only one can be open at a time
        // this closes the infoWindow if one exists already, so when changing to another view an existing infoWindow cannot be carried to that view
        if(infowindow) {
          infowindow.close();
        }
        infowindow = new google.maps.InfoWindow();

        fetch('/stations')
            .then(response => response.json())
            .then(stationData =>  {

                for (const station of stationData) {
                  let stationProperty = viewAvailableBikes ? station.availableBikes : station.freeStands;
                  // get the marker colour according to the current selected view
                  let colourIcon = getMarkerColour(stationProperty, station.totalStands);
                  // this replaces the char `'` with ' ' in the station name when passed to displayChart() because it was causing troubles when clicking the "More" button
                  const stationName = station.name.replaceAll("'", " ");
                  // get the infoWindow content (number of bikes and free spaces for each station)
                  let contentString = getWindowContent(station, stationName);
                  
                  // code to create markers the first time the page loads
                  // check if all station markers were added to the markersArray, if not it means it is still the first time a station marker is being created
                  if (markersArray.length != stationData.length) {
                    const newMarker = new google.maps.Marker({
                        position: {'lat': station.latitude, 'lng': station.longitude},
                        icon: colourIcon,
                        map,
                    });
                    // add the station marker to the array markersArray
                    markersArray.push(newMarker);
                    newMarker.addListener("click", () => {
                      // Close any open info window
                      if (infowindow) infowindow.close();
                      infowindow.setContent(contentString);
                      infowindow.open(map, newMarker);
                  });
                  }
                  else{
                    // this code makes it possible to just update the marker's colours and infoWindow content when changing the view, instead of creating new markers (fixes bug where markers were off after changing views)
                    // get marker from markersArray that belongs to the station
                    for (marker of markersArray) {
                      markerPosition = marker.getPosition();
                      markerLat = markerPosition.lat();
                      markerLong = markerPosition.lng();
                      if (markerLat == station.latitude && markerLong == station.longitude) {
                        // clear previous listeners to update content string (meanwhile number of bikes/spaces might have changed)
                        google.maps.event.clearListeners(marker, 'click');
                        // update marker colour
                        marker.setIcon(getMarkerColour(stationProperty, station.totalStands));
                        // get updated content for infowindow
                        let contentString = getWindowContent(station, stationName);
                        google.maps.event.addListener(this.marker, 'click', function () {
                          // Close any open info window
                          if (infowindow) infowindow.close();
                          // add the updated content and open the infoWindow
                          infowindow.setContent(contentString);
                          infowindow.open(this.getMap(), this);
                        });
                      }
                    }
                  }
                }
            })
        .then(() => overlay.hide());
        };
      
      function changeViewTitle() {
        let viewTitle = document.getElementById("viewTitle");
        if(viewAvailableBikes){
          viewTitle.textContent = "Viewing Available Bikes";
        } 
        else {
          viewTitle.textContent = "Viewing Free Spaces";
        }
      };

      function getMarkerColour(stationProperty, totalStands) {
        let colourIcon;
        // Assign different colours to stations based on percentage bike availability
        // The ranges for each colour were decided to ensure an approximately equal
        // number of stations in each group based on historical data
        if (stationProperty / totalStands < 0.26) {
            colourIcon = "/static/red-square.png";
        } else if (stationProperty / totalStands < 0.44) {
            colourIcon = "/static/ylw-square.png";
        } else {
            colourIcon = "/static/grn-square.png";
        }
        return colourIcon;
      };

      function getWindowContent(station, stationName){
        // Information displayed in info window (the same in both views)
        let contentString =
                    station.name +
                    "<ul>" +
                    "<li>Available Bikes: " + station.availableBikes + "</li>" +
                    "<li>Free Stands: " + station.freeStands + "</li>" +
                    "</ul>" +
                    "<button type='button' id='moreButton' onclick='displayChart(" + station.stationId + ",\"" + stationName + "\")'>More</button>";
        return contentString;
      };

      // function to display the bikes or spaces availability trend chart when the "More" button is clicked
      function displayChart(stationId, stationName) {
        let endpoint;
        if (viewAvailableBikes) {
          endpoint = '/availability_history?stationId=' + stationId;
        } 
        else {
          endpoint = '/available_spaces_history?stationId=' + stationId;
        }
          fetch(endpoint)
          .then(response => response.json())
          .then(stationHistory => {
            // each dataset is a day of the week with the avg availability for every hour of the day
            let datasets = [];
            createChartDataset(stationHistory, datasets);
            // create a canvas where the chart will be displayed
            let canvas = document.getElementById('trendChart');
            let ctx = canvas.getContext('2d');
            // the title in the y-axis in the chart will change accordingly with the view that is selected
            let labelTitle;
            if (viewAvailableBikes){
              labelTitle = "Bikes Available"
            }
            else {
              labelTitle = "Free Spaces"
            }
            // create the chart for each dataset and station
            createChart(ctx, datasets, stationName, labelTitle);
            // Get the modal
            let modal = document.getElementById("myModal");
            // show the modal
            modal.style.display = "block";
        })
      };

      function createChartDataset(stationHistory, datasets) {
        // keys will be a list with [0, 1, 2, 3, etc.] -- 0=Monday; 1=Tuesday; etc.
        const keys = Object.keys(stationHistory);
        // dicts to convert the keys that we get from stationAvailabilityHistory into the weekdays and give a color to each of the days for our chart
        let labelsDict = {0: "Monday", 1: "Tuesday", 2: "Wednesday", 3: "Thursday", 4: "Friday", 5: "Saturday", 6: "Sunday"};
        let colorsDict = {0: "#622569", 1: "#80ced6", 2: "#ada397", 3: "#e0876a", 4: "#ffcc5c", 5: "#034f84", 6: "#82b74b"};
        for(var i = 0; i < keys.length; i++) {
          let dayDataset = {label: labelsDict[i], data: [], fill: false, borderColor: colorsDict[i]};
          for (var j = 0; j < stationHistory[keys[i]].length; j++) {
            if (viewAvailableBikes){
              dayDataset.data.push(stationHistory[keys[i]][j].availableBikes);
            }
            else {
              dayDataset.data.push(stationHistory[keys[i]][j].freeStands);
            }
          }
          datasets.push(dayDataset);
        }
      };

      function createChart(ctx, datasets, stationName, labelTitle) {
        chart = new Chart(ctx, {
              type: 'line',
              data: {
                  datasets: datasets,
                  labels: ['0h', '1h', '2h', '3h', '4h', '5h', '6h', '7h', '8h', '9h', '10h', '11h', '12h', '13h', '14h', '15h', '16h', '17h', '18h', '19h', '20h', '21h', '22h', '23h']
              },
              responsive: true,
              maintainAspectRatio: false,
              options: {
                legend: {
                  labels: {
                    fontSize: 20,
                  }
                },
                tooltips: {
                  titleFontSize: 20,
                  bodyFontSize: 20,
                },
                title: {
                    display: true,
                    text: stationName,
                    fontSize: 30,
                },
                scales: {
                  yAxes: [{
                    ticks: {
                      fontSize: 22,
                    },
                    scaleLabel: {
                      display: true,
                      labelString: labelTitle,
                      fontSize: 25,
                    }
                  }],
                  xAxes: [{
                    ticks: {
                      fontSize: 20,
                    },
                      scaleLabel: {
                        display: true,
                        labelString: 'Hours',
                        fontSize: 25,
                      }
                    }]
                  },       
                }
              },
            )
            // Get the modal
            let modal = document.getElementById("myModal");
            // show the modal
            modal.style.display = "block";
      }

    </script>
  </head>
  <body>
    <div id="header"><h1>Group 5 Dublin Bikes App</h1></div>
    <script src="/weatherWidget.js"></script>
    <div id="openweather-widget"></div>
    <div class="view-title-div">
      <h3 id="viewTitle"></h3>
    </div>
    <div class="view-selection">
      <button class="select-view-button" id="availableBikesButton" onclick="selectAvailableBikesView()">Available Bikes</button>
      <button class="select-view-button" id="availableSpacesButton" onclick="selectFreeSpacesView()">Free Spaces</button>
    </div>
    <div id="map"></div>
    <div id="myModal" class="modal">
      <span class="close">&times;</span>
      <canvas class="modal-content" id="trendChart"></canvas>
    </div>
    
    <!-- Async script executes immediately and must be after any DOM elements used in callback. -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCrzloaJPiuP3QvxoeLVdLyWZsh7oTAXm4&callback=initMap&libraries=&v=weekly"
      async
    ></script>
    <script>
      // Get the modal
      let modal = document.getElementById("myModal");
      
      // Get the <span> element that closes the modal
      let span = document.getElementsByClassName("close")[0];

      // When the user clicks on <span> (x), close the modal (the chart)
      span.onclick = function() {
        modal.style.display = "none";
        // delete chart before creating a new chart in the canvas
        chart.destroy();
      }

      // When the user clicks anywhere outside of the modal (grey area in the background), also close the chart
      window.onclick = function(event) {
        if (event.target == modal) {
          modal.style.display = "none";
          // delete chart before creating a new chart in the canvas
          chart.destroy();
        }
      }
    </script>
  </body>
</html>
